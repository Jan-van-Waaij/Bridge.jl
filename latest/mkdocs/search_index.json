{
    "docs": [
        {
            "location": "/", 
            "text": "Bridge.jl\n\n\nDocumentation for Bridge.jl\n\n\n\n\nImportant concepts\n\n\n#\n\n\nBridge.ContinuousTimeProcess\n \n \nType\n.\n\n\nContinuousTimeProcess{T}\n\n\n\n\nTypes inheriting from the abstract type ContinuousTimeProcess{T} characterize  the properties of a \nT\n-valued stochastic process, play a similar role as distribution types like \nExponential\n in the package \nDistributions\n.\n\n\nsource\n\n\n#\n\n\nBridge.SamplePath\n \n \nType\n.\n\n\nSamplePath{T} \n: AbstractPath{T}\n\n\n\n\nThe struct\n\n\nstruct SamplePath{T}\n    tt::Vector{Float64}\n    yy::Vector{T}\n    SamplePath{T}(tt, yy) where {T} = new(tt, yy)\nend\n\n\n\n\nserves as container for discretely observed \nContinuousTimeProcess\nes and for the sample path returned by direct and approximate samplers. \ntt``is the vector of the grid points of the observation/simulation  and\nyy` is the corresponding vector of states.\n\n\nIt supports \ngetindex, setindex!, length, copy, vcat, start, next, done, endof\n.\n\n\nsource\n\n\n#\n\n\nBase.valtype\n \n \nFunction\n.\n\n\nvaltype(::ContinuousTimeProcess) -\n T\n\n\n\n\nReturns statespace (type) of a \nContinuousTimeProcess{T]\n.\n\n\nsource\n\n\n\n\nOrdinary differential equations\n\n\n#\n\n\nBridge.solve!\n \n \nFunction\n.\n\n\nsolve!(method, X::SamplePath, x0, P) -\n X, [err]\n\n\n\n\nSolve ordinary differential equation \n(d/dx) x(t) = F(t, x(t), P)\n on the fixed grid \nX.tt\n writing into \nX.yy\n \n\n\nmethod::R3\n - using a non-adaptive Ralston (1965) update (order 3).\n\n\nmethod::BS3\n use non-adaptive Bogacki\u2013Shampine method to give error estimate.\n\n\nCall \n_solve!\n to inline. \"Pretty fast if \nx\n is a bitstype or a StaticArray.\"\n\n\nsource\n\n\n#\n\n\nBridge.R3\n \n \nType\n.\n\n\nR3\n\n\n\n\nRalston (1965) update (order 3 step of the Bogacki\u2013Shampine 1989 method) to solve $y(t + dt) - y(t) = int_t^{t+dt} f(s, y(s)) ds$.\n\n\nsource\n\n\n#\n\n\nBridge.BS3\n \n \nType\n.\n\n\nBS3\n\n\n\n\nRalston (1965) update (order 3 step of the Bogacki\u2013Shampine 1989 method) to solve $y(t + dt) - y(t) = int_t^{t+dt} f(s, y(s)) ds$. Uses Bogacki\u2013Shampine method  to give error estimate. \n\n\nsource\n\n\n\n\nBrownian motion\n\n\n\n\nStochastic differential equations\n\n\n#\n\n\nStatsBase.sample\n \n \nFunction\n.\n\n\n sample(tt, P, x1=zero(T))\n\n\n\n\nSample the process \nP\n on the grid \ntt\n exactly from its \ntransitionprob\n(-ability) starting in \nx1\n.\n\n\nsource\n\n\n#\n\n\nStatsBase.sample!\n \n \nFunction\n.\n\n\n sample!(X, P, x1=zero(T))\n\n\n\n\nSample the process \nP\n on the grid \nX.tt\n exactly from its \ntransitionprob\n(-ability) starting in \nx1\n writing into \nX.yy\n.\n\n\nsource\n\n\n#\n\n\nBridge.quvar\n \n \nFunction\n.\n\n\nquvar(X)\n\n\n\n\nComputes quadratic variation of \nX\n.\n\n\nsource\n\n\n#\n\n\nBridge.bracket\n \n \nFunction\n.\n\n\nbracket(X)\nbracket(X,Y)\n\n\n\n\nComputes quadratic variation process of \nX\n (of \nX\n and \nY\n).\n\n\nsource\n\n\n#\n\n\nBridge.ito\n \n \nFunction\n.\n\n\nito(Y, X)\n\n\n\n\nIntegrate a valued stochastic process with respect to a stochastic differential.\n\n\nsource\n\n\n#\n\n\nBridge.girsanov\n \n \nFunction\n.\n\n\ngirsanov{T}(X::SamplePath{T}, P::ContinuousTimeProcess{T}, Pt::ContinuousTimeProcess{T})\n\n\n\n\nGirsanov log likelihood $dP/dPt(X)$    \n\n\nsource\n\n\n#\n\n\nBridge.lp\n \n \nFunction\n.\n\n\nlp(s, x, t, y, P)\n\n\nLog-transition density, shorthand for \nlogpdf(transitionprob(s,x,t,P),y)\n.\n\n\nsource\n\n\n#\n\n\nBridge.llikelihood\n \n \nFunction\n.\n\n\n llikelihood(X::SamplePath, P::ContinuousTimeProcess)\n\n\n\n\nLog-likelihood of observations \nX\n using transition density \nlp\n\n\nsource\n\n\nLog-likelihood with respect to reference measure P.P\n\n\nUp to proportionality\n\n\nsource\n\n\nBridge log-likelihood with respect to reference measure P.P\n\n\nUp to proportionality\n\n\nsource\n\n\n\n\nMiscellaneous\n\n\n#\n\n\nBridge.endpoint!\n \n \nFunction\n.\n\n\nendpoint!(X::SamplePath, v)\n\n\n\n\nConvenience functions setting the endpoint of \nX``to\nv`.\n\n\nsource\n\n\n\n\nUnsorted\n\n\n#\n\n\nBridge.ODESolver\n \n \nType\n.\n\n\nODESolver\n\n\n\n\nAbstract (super-)type for solving methods for ordinary differential equations.\n\n\nsource\n\n\n#\n\n\nBridge.mcbandmean\n \n \nFunction\n.\n\n\nmcmeanband(mc)\n\n\n\n\nCompute marginal confidence interval for the chain mean using normal approximation\n\n\nsource\n\n\n#\n\n\nBridge.cumsum0\n \n \nFunction\n.\n\n\ncumsum0\n\n\n\n\nCumulative sum starting at 0, \n\n\nsource\n\n\n#\n\n\nBridge.LocalGammaProcess\n \n \nType\n.\n\n\nLocalGammaProcess\n\n\nsource\n\n\n#\n\n\nBridge.Ptilde\n \n \nType\n.\n\n\nPtilde(cs::CSpline, \u03c3)\n\n\n\n\nAffine diffusion $dX = cs(t) dt + \u03c3dW$  with cs a \n\n\nsource\n\n\n#\n\n\nBridge.GuidedProp\n \n \nType\n.\n\n\nGuidedProp\n\n\n\n\nGeneral bridge proposal process\n\n\nsource\n\n\n#\n\n\nBridge.compensator0\n \n \nFunction\n.\n\n\ncompensator0(kstart, P::LocalGammaProcess)\n\n\n\n\nCompensator of GammaProcess approximating the LocalGammaProcess. For kstart == 1 (only choice) this is nu([b1,Inf], P0)\n\n\nsource\n\n\n#\n\n\nBridge.mcstart\n \n \nFunction\n.\n\n\nmcstart(x) -\n state\n\n\n\n\nCreate state for random chain online statitics. The entries/value of \nx\n are ignored\n\n\nsource\n\n\n#\n\n\nBridge.CSpline\n \n \nType\n.\n\n\nCSpline(s, t, x, y = x, m0 = (y-x)/(t-s), m1 =  (y-x)/(t-s))\n\n\n\n\nCubic spline parametrized by f(s) = x and f(t) = y, f'(x) = m0, f'(t) = m1\n\n\nsource\n\n\n#\n\n\nBridge.tofs\n \n \nFunction\n.\n\n\ntofs(s, T1, T2)\nsoft(t, T1, T2)\n\nTime change mapping t in [T1, T2] (X-time) to s in [T1, T2]  (U-time).\n\n\n\n\nsource\n\n\n#\n\n\nBridge.r\n \n \nFunction\n.\n\n\nr(t, x, T, v, P)\n\n\n\n\nReturns $r(t,x) = \\operatorname{grad}_x \\log p(t,x; T, v)$ where $p$ is the transition density of the process $P$.\n\n\nsource\n\n\n#\n\n\nBridge.\u03b8\n \n \nFunction\n.\n\n\nInverse jump size compared to gamma process with same alpha and beta\n\n\nsource\n\n\n#\n\n\nBridge.gpK!\n \n \nFunction\n.\n\n\ngpK!(K::SamplePath, P)\n\n\n\n\nPrecompute $K = H^{-1}$ from $(d/dt)K = BK + KB' + a$ for a guided proposal.\n\n\nsource\n\n\n#\n\n\nBridge.mcnext\n \n \nFunction\n.\n\n\nmcnext(state, x) -\n state\n\n\n\n\nUpdate random chain online statistics when new chain value \nx\n was observed. Return new \nstate\n.\n\n\nsource\n\n\n#\n\n\nBridge.compensator\n \n \nFunction\n.\n\n\ncompensator(kstart, P::LocalGammaProcess)\n\n\n\n\nCompensator of LocalGammaProcess \n\n\nfor kstart = 1, this is sum_k=1^N nu(B_k) for kstart = 0, this is sum_k=0^N nu(B_k) - C (where C is a constant)\n\n\nsource\n\n\n#\n\n\nBridge.outer\n \n \nFunction\n.\n\n\nouter(x[, y])\n\n\n\n\nShort-hand for quadratic form xx' (or xy').\n\n\nsource\n\n\n#\n\n\nBridge.integrate\n \n \nFunction\n.\n\n\nintegrate(cs::CSpline, s, t)\n\n\n\n\nIntegrate the cubic spline from s to t    \n\n\nsource\n\n\n#\n\n\nBridge.soft\n \n \nFunction\n.\n\n\nsoft(t, T1, T2)\n\nTime change mapping s in [T1, T2] (U-time) to t in [T1, T2] (X-time), and inverse.\n\n\n\n\nsource\n\n\n#\n\n\nBridge.nu\n \n \nFunction\n.\n\n\n(Bin-wise) integral of the Levy measure\n\n\nsource\n\n\n#\n\n\nBridge.bridge\n \n \nFunction\n.\n\n\nbridge(W, P, scheme! = euler!) -\n Y\n\n\n\n\nIntegrate with $scheme!$ and set $Y[end] = P.v1$.\n\n\nsource\n\n\n#\n\n\nBridge.Vs\n \n \nFunction\n.\n\n\nVs (s, T1, T2, v, B, beta)\n\n\n\n\nTime changed V for generation of U\n\n\nsource\n\n\n#\n\n\nBridge.logpdfnormal\n \n \nFunction\n.\n\n\nlogpdfnormal(x, A)\n\n\n\n\nlogpdf of centered gaussian with covariance A\n\n\nsource\n\n\n#\n\n\nBridge.mdb!\n \n \nFunction\n.\n\n\nmdb(u, W, P)\nmdb!(copy(W), u, W, P)\n\n\n\n\nEuler scheme with the diffusion coefficient correction of the modified diffusion bridge.\n\n\nsource\n\n\n#\n\n\nBridge.euler!\n \n \nFunction\n.\n\n\neuler!(Y, u, W, P) -\n X\n\n\n\n\nSolve stochastic differential equation $dX_t = b(t,X_t)dt + \u03c3(t,X_t)dW_t$  using the Euler scheme in place.\n\n\nsource\n\n\n#\n\n\nBridge.GammaProcess\n \n \nType\n.\n\n\nGammaProcess\n\n\n\n\nA \nGammaProcess\n with jump rate \n\u03b3\n and inverse jump size \n\u03bb\n has increments \nGamma(t*\u03b3, 1/\u03bb)\n and Levy measure\n\n\n$$\n\u03bd(x)=\u03b3 x^{-1}\\exp(-\u03bb x), \n$$\n\n\nHere \nGamma(\u03b1,\u03b8)\n is the Gamma distribution in julia's parametrization with shape parameter \n\u03b1\n and scale \n\u03b8\n\n\nsource\n\n\n#\n\n\nBridge.dotVs\n \n \nFunction\n.\n\n\ndotVs (s, T, v, B, beta)\n\n\n\n\nTime changed time derivative of V for generation of U\n\n\nsource\n\n\n#\n\n\nBridge.mdb\n \n \nFunction\n.\n\n\nmdb(u, W, P)\nmdb!(copy(W), u, W, P)\n\n\n\n\nEuler scheme with the diffusion coefficient correction of the modified diffusion bridge.\n\n\nsource\n\n\n#\n\n\nBridge.euler\n \n \nFunction\n.\n\n\neuler(u, W, P) -\n X\n\n\n\n\nSolve stochastic differential equation $dX_t = b(t,X_t)dt + \u03c3(t,X_t)dW_t$ using the Euler scheme.\n\n\nsource\n\n\n#\n\n\nBridge.mat\n \n \nFunction\n.\n\n\nmat(X::SamplePath{SVector}) \nmat(yy::Vector{SVector})\n\n\n\n\nReinterpret \nX\n or \nyy\n to an array without change in memory.\n\n\nsource\n\n\n#\n\n\nBridge.thetamethod\n \n \nFunction\n.\n\n\nthetamethod(u, W, P, theta=0.5)\n\n\n\n\nSolve stochastic differential equation using the theta method and Newton-Raphson steps\n\n\nsource\n\n\n#\n\n\nBridge.mcband\n \n \nFunction\n.\n\n\nmcband(mc)\n\n\n\n\nCompute marginal 95% coverage interval for the chain from normal approximation.\n\n\nsource\n\n\n#\n\n\nBridge.LinPro\n \n \nType\n.\n\n\nLinPro(B, \u03bc::T, \u03c3)\n\n\n\n\nLinear diffusion $dX = B(X - \u03bc)dt + \u03c3dW$\n\n\nsource", 
            "title": "Home"
        }, 
        {
            "location": "/#bridgejl", 
            "text": "Documentation for Bridge.jl", 
            "title": "Bridge.jl"
        }, 
        {
            "location": "/#important-concepts", 
            "text": "#  Bridge.ContinuousTimeProcess     Type .  ContinuousTimeProcess{T}  Types inheriting from the abstract type ContinuousTimeProcess{T} characterize  the properties of a  T -valued stochastic process, play a similar role as distribution types like  Exponential  in the package  Distributions .  source  #  Bridge.SamplePath     Type .  SamplePath{T}  : AbstractPath{T}  The struct  struct SamplePath{T}\n    tt::Vector{Float64}\n    yy::Vector{T}\n    SamplePath{T}(tt, yy) where {T} = new(tt, yy)\nend  serves as container for discretely observed  ContinuousTimeProcess es and for the sample path returned by direct and approximate samplers.  tt``is the vector of the grid points of the observation/simulation  and yy` is the corresponding vector of states.  It supports  getindex, setindex!, length, copy, vcat, start, next, done, endof .  source  #  Base.valtype     Function .  valtype(::ContinuousTimeProcess) -  T  Returns statespace (type) of a  ContinuousTimeProcess{T] .  source", 
            "title": "Important concepts"
        }, 
        {
            "location": "/#ordinary-differential-equations", 
            "text": "#  Bridge.solve!     Function .  solve!(method, X::SamplePath, x0, P) -  X, [err]  Solve ordinary differential equation  (d/dx) x(t) = F(t, x(t), P)  on the fixed grid  X.tt  writing into  X.yy    method::R3  - using a non-adaptive Ralston (1965) update (order 3).  method::BS3  use non-adaptive Bogacki\u2013Shampine method to give error estimate.  Call  _solve!  to inline. \"Pretty fast if  x  is a bitstype or a StaticArray.\"  source  #  Bridge.R3     Type .  R3  Ralston (1965) update (order 3 step of the Bogacki\u2013Shampine 1989 method) to solve $y(t + dt) - y(t) = int_t^{t+dt} f(s, y(s)) ds$.  source  #  Bridge.BS3     Type .  BS3  Ralston (1965) update (order 3 step of the Bogacki\u2013Shampine 1989 method) to solve $y(t + dt) - y(t) = int_t^{t+dt} f(s, y(s)) ds$. Uses Bogacki\u2013Shampine method  to give error estimate.   source", 
            "title": "Ordinary differential equations"
        }, 
        {
            "location": "/#brownian-motion", 
            "text": "", 
            "title": "Brownian motion"
        }, 
        {
            "location": "/#stochastic-differential-equations", 
            "text": "#  StatsBase.sample     Function .   sample(tt, P, x1=zero(T))  Sample the process  P  on the grid  tt  exactly from its  transitionprob (-ability) starting in  x1 .  source  #  StatsBase.sample!     Function .   sample!(X, P, x1=zero(T))  Sample the process  P  on the grid  X.tt  exactly from its  transitionprob (-ability) starting in  x1  writing into  X.yy .  source  #  Bridge.quvar     Function .  quvar(X)  Computes quadratic variation of  X .  source  #  Bridge.bracket     Function .  bracket(X)\nbracket(X,Y)  Computes quadratic variation process of  X  (of  X  and  Y ).  source  #  Bridge.ito     Function .  ito(Y, X)  Integrate a valued stochastic process with respect to a stochastic differential.  source  #  Bridge.girsanov     Function .  girsanov{T}(X::SamplePath{T}, P::ContinuousTimeProcess{T}, Pt::ContinuousTimeProcess{T})  Girsanov log likelihood $dP/dPt(X)$      source  #  Bridge.lp     Function .  lp(s, x, t, y, P)  Log-transition density, shorthand for  logpdf(transitionprob(s,x,t,P),y) .  source  #  Bridge.llikelihood     Function .   llikelihood(X::SamplePath, P::ContinuousTimeProcess)  Log-likelihood of observations  X  using transition density  lp  source  Log-likelihood with respect to reference measure P.P  Up to proportionality  source  Bridge log-likelihood with respect to reference measure P.P  Up to proportionality  source", 
            "title": "Stochastic differential equations"
        }, 
        {
            "location": "/#miscellaneous", 
            "text": "#  Bridge.endpoint!     Function .  endpoint!(X::SamplePath, v)  Convenience functions setting the endpoint of  X``to v`.  source", 
            "title": "Miscellaneous"
        }, 
        {
            "location": "/#unsorted", 
            "text": "#  Bridge.ODESolver     Type .  ODESolver  Abstract (super-)type for solving methods for ordinary differential equations.  source  #  Bridge.mcbandmean     Function .  mcmeanband(mc)  Compute marginal confidence interval for the chain mean using normal approximation  source  #  Bridge.cumsum0     Function .  cumsum0  Cumulative sum starting at 0,   source  #  Bridge.LocalGammaProcess     Type .  LocalGammaProcess  source  #  Bridge.Ptilde     Type .  Ptilde(cs::CSpline, \u03c3)  Affine diffusion $dX = cs(t) dt + \u03c3dW$  with cs a   source  #  Bridge.GuidedProp     Type .  GuidedProp  General bridge proposal process  source  #  Bridge.compensator0     Function .  compensator0(kstart, P::LocalGammaProcess)  Compensator of GammaProcess approximating the LocalGammaProcess. For kstart == 1 (only choice) this is nu([b1,Inf], P0)  source  #  Bridge.mcstart     Function .  mcstart(x) -  state  Create state for random chain online statitics. The entries/value of  x  are ignored  source  #  Bridge.CSpline     Type .  CSpline(s, t, x, y = x, m0 = (y-x)/(t-s), m1 =  (y-x)/(t-s))  Cubic spline parametrized by f(s) = x and f(t) = y, f'(x) = m0, f'(t) = m1  source  #  Bridge.tofs     Function .  tofs(s, T1, T2)\nsoft(t, T1, T2)\n\nTime change mapping t in [T1, T2] (X-time) to s in [T1, T2]  (U-time).  source  #  Bridge.r     Function .  r(t, x, T, v, P)  Returns $r(t,x) = \\operatorname{grad}_x \\log p(t,x; T, v)$ where $p$ is the transition density of the process $P$.  source  #  Bridge.\u03b8     Function .  Inverse jump size compared to gamma process with same alpha and beta  source  #  Bridge.gpK!     Function .  gpK!(K::SamplePath, P)  Precompute $K = H^{-1}$ from $(d/dt)K = BK + KB' + a$ for a guided proposal.  source  #  Bridge.mcnext     Function .  mcnext(state, x) -  state  Update random chain online statistics when new chain value  x  was observed. Return new  state .  source  #  Bridge.compensator     Function .  compensator(kstart, P::LocalGammaProcess)  Compensator of LocalGammaProcess   for kstart = 1, this is sum_k=1^N nu(B_k) for kstart = 0, this is sum_k=0^N nu(B_k) - C (where C is a constant)  source  #  Bridge.outer     Function .  outer(x[, y])  Short-hand for quadratic form xx' (or xy').  source  #  Bridge.integrate     Function .  integrate(cs::CSpline, s, t)  Integrate the cubic spline from s to t      source  #  Bridge.soft     Function .  soft(t, T1, T2)\n\nTime change mapping s in [T1, T2] (U-time) to t in [T1, T2] (X-time), and inverse.  source  #  Bridge.nu     Function .  (Bin-wise) integral of the Levy measure  source  #  Bridge.bridge     Function .  bridge(W, P, scheme! = euler!) -  Y  Integrate with $scheme!$ and set $Y[end] = P.v1$.  source  #  Bridge.Vs     Function .  Vs (s, T1, T2, v, B, beta)  Time changed V for generation of U  source  #  Bridge.logpdfnormal     Function .  logpdfnormal(x, A)  logpdf of centered gaussian with covariance A  source  #  Bridge.mdb!     Function .  mdb(u, W, P)\nmdb!(copy(W), u, W, P)  Euler scheme with the diffusion coefficient correction of the modified diffusion bridge.  source  #  Bridge.euler!     Function .  euler!(Y, u, W, P) -  X  Solve stochastic differential equation $dX_t = b(t,X_t)dt + \u03c3(t,X_t)dW_t$  using the Euler scheme in place.  source  #  Bridge.GammaProcess     Type .  GammaProcess  A  GammaProcess  with jump rate  \u03b3  and inverse jump size  \u03bb  has increments  Gamma(t*\u03b3, 1/\u03bb)  and Levy measure  $$\n\u03bd(x)=\u03b3 x^{-1}\\exp(-\u03bb x), \n$$  Here  Gamma(\u03b1,\u03b8)  is the Gamma distribution in julia's parametrization with shape parameter  \u03b1  and scale  \u03b8  source  #  Bridge.dotVs     Function .  dotVs (s, T, v, B, beta)  Time changed time derivative of V for generation of U  source  #  Bridge.mdb     Function .  mdb(u, W, P)\nmdb!(copy(W), u, W, P)  Euler scheme with the diffusion coefficient correction of the modified diffusion bridge.  source  #  Bridge.euler     Function .  euler(u, W, P) -  X  Solve stochastic differential equation $dX_t = b(t,X_t)dt + \u03c3(t,X_t)dW_t$ using the Euler scheme.  source  #  Bridge.mat     Function .  mat(X::SamplePath{SVector}) \nmat(yy::Vector{SVector})  Reinterpret  X  or  yy  to an array without change in memory.  source  #  Bridge.thetamethod     Function .  thetamethod(u, W, P, theta=0.5)  Solve stochastic differential equation using the theta method and Newton-Raphson steps  source  #  Bridge.mcband     Function .  mcband(mc)  Compute marginal 95% coverage interval for the chain from normal approximation.  source  #  Bridge.LinPro     Type .  LinPro(B, \u03bc::T, \u03c3)  Linear diffusion $dX = B(X - \u03bc)dt + \u03c3dW$  source", 
            "title": "Unsorted"
        }
    ]
}